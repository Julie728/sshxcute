#labels Featured
<wiki:toc max_depth="4" />

=1. 概述=
正如名字所示，SSHXCUTE是一个框架。它允许工程师利用Java代码通过SSH连接远程执行Linux/UNIX系统上的命令或者脚本，这种方式不管是针对软件测试还是系统部署，都简化了自动化测试与系统环境部署的步骤。

SSHXCUTE的设计旨在：
  * 最小的系统需求 – 仅仅开启SSH连接即可。
  * 易用性 – 工程师利用Java代码执行命令或脚本。
  * 内置命令/脚本任务执行功能。
  * 易扩展 – 用户可以自定义任务类型并集成于sshxcute框架。

=2. 适用范围与限制=
==2.1 限制==
  * 远程Linux/UNIX机器必须开启SSH连接，并且需要用户名密码认证登录。
  * 你只能将sshxcute的jar引入你的基于Java的项目才能使用或者将这个jar包置于$CLASSPATH。
  * JDK版本要高于或等于5.0

==2.2 适用范围==
*场景1.* 如果你有一大堆命令或者脚本需要在远程机器上跑一跑（比如部署一下开发或者生产环境），而这些手动输入命令的工作又是如此的无聊，你也不想花功夫去编写一个脚本统一调用这些命令或脚本。更好的情况是你在用Java IDE（比如Eclipse），好的！为什么不试试sshxcute呢? 在你的工作主机比如windows或ubuntu上执行命令，那看着多惬意啊~

*场景2.* 你的自动化工具是用Java写的，你有一些需求需要在远程的Linux/UNIX服务器上执行一些命令或脚本，sshxcute正你的大爱！把sshxcute.jar导入到你的项目中，你就可以神奇般的调用它的API了！开始远程执行旅行~

=3. 使用指南=
首先，你必须确保sshxcute.jar已经在你的JRE的$CLASSPATH中，然后你才可以开始。接下来展示的是如何在Eclipse IDE中配置Java Build Path。右键单击项目 > 属性 > Java构建路径。更多的配置步骤请上网搜索。

http://neoremind.net/wp-content/uploads/2010/09/howtoimport.jpg

==3.1初始化准备工作==
通常当我们需要在远程Linux/UNIX系统上执行命令时，以下是必须的步骤：

  * 1) 打开SSH连接客户端（例如Putty）
  * 2) 输入IP
  * 3) 输入用户名、密码登陆
  * 4) 登陆成功后输入命令行
  * 5) 断开登陆

前三个步骤可以通过sshxcute的Java API模拟实现：
{{{
// 新建一个ConnBean对象，三个参数依次是ip地址、用户名、密码
ConnBean cb = new ConnBean("ip ", "username","password");
// 将上面新建的ConnBean作为参数传递给SSHExec的静态单例方法，得到一个SSHExec的实例
ssh = SSHExec.getInstance(cb);		
// 利用上面得到的SSHExec实例连接主机
ssh.connect();
}}}

第五步实现如下：
{{{
ssh.disconnect();
}}}
	
第四步是才是SSHEXEC框架的核心所在——执行命令或者脚本。接下来的部分将主要介绍这个主题。


==3.2 远程执行命令==
让我们先来看一段代码再来详细解释。因为如果你已经具备了面向对象编程经验，你将会发现这是如此的简单。
{{{
CustomTask sampleTask = new ExecCommand("echo 123");
ssh.exec(sampleTask);
}}}

ExecCommand类继承了CustomTask类，我们新建一个ExecCommand对象，他的引用类型是CustomTask。下图展示了ExecCommand、ExecShellScript和CustomTask的类图，从中可以看出他们的关系。

http://neoremind.net/wp-content/uploads/2010/09/sshxcute_classdiagram.jpg

ExecCommand的构造函数只接收一个字符串类型变量。注意ExecCommand可以执行多个命令，只需要用分隔符“,”分隔各个命令即可。例如：
{{{
CustomTask sampleTask = new ExecCommand("echo 123", "echo 456, "echo 789");
}}}

ExecCommand的构造函数是：
  * `public ExecCommand(String...args)`

把ExecCommand对象作为参数传入SSHExec.exec(CustomTask)方法，这样就可以直接运行了。

==3.3 远程执行shell脚本==
远程执行shell脚本几乎与3.2小节的远程执行命令一致。例如，如果你想执行/home/tsadmin路径下的sshxcute_test.sh脚本，并且带两个参数“hello world”，你可以这样调用：
{{{
CustomTask ct1 = new ExecShellScript("/home/tsadmin","./sshxcute_test.sh","hello world");
ssh.exec(ct1);
}}}

ExecShellScript的构造函数是：
  * `public ExecShellScript(String workingDir, String shellPath, String args)`
	
  * `public ExecShellScript(String shellPath, String args)`
	
  * `public ExecShellScript(String shellPath)`


==3.4 上传文件==
我们会遇到一种情况，要执行的脚本是存在于我们本地的，我们必须先把其上传到远程的机器上。这项工作sshxcute同样可以为我们完成，例如，我们想要把c:/data2/data目录下的所有文件上传到远程机器上的/home/tsadmin目录下，我们可以
{{{
ssh.uploadAllDataToServer("c:/data2/data", "/home/tsadmin");
}}}

如果想只上传单一文件，例如只上传项目路径下的data/sshxcute_test.sh到/home/tsadmin，我们可以这样
{{{
ssh.uploadSingleDataToServer("data/sshxcute_test.sh","/home/tsadmin");
}}}

这里要注意下，我们必须把顺序搞清楚，上传的步骤必须在执行前，连接成功后。例如：
{{{
CustomTask ct1 = new ExecShellScript("/home/tsadmin","./sshxcute_test.sh","hello world");
ssh.connect();  // 连接成功后
ssh.uploadSingleDataToServer("data/sshxcute_test.sh", "/home/tsadmin");
ssh.exec(ct1);  // 执行前
}}}

当然这里不仅仅限于必须执行脚本，如果你只想上传文件可以单独执行uploadSingleDataToServer与uploadSingleDataToServer方法。

==3.5 结果对象==
所有的任务类型，包括我们上面已经讲解过的ExecCommand、ExecShellScript还有我们接下来会说明的自定义类任务，在执行完毕后，都会返回一个结果对象（Result）。这个结果对象包含了命令或者脚本的返回代码（return code）、标准输入、错误输出。还有它会提供一个布尔类型的isSuccess变量供程序员判断是否任务执行成功，在[http://code.google.com/p/sshxcute/wiki/GuidelineOfChineseVersion?ts=1284185859&updated=GuidelineOfChineseVersion#4.1_判定任务成功与否的过滤关键字 4.1章节]我们将会详细介绍sshxcute是如何判断任务执行成功与否的，这个判断的条件也是可以配置的。

例如，我们的SSHExec.exec(CustomTask)总会返回一个结果对象，我们可以利用自己的逻辑代码打印一些有用的信息。
{{{
Result res = ssh.exec(task);
if (res.isSuccess)
{
	System.out.println("Return code: " + res.rc);
	System.out.println("sysout: " + res.sysout);
}
else
{
	System.out.println("Return code: " + res.rc);
	System.out.println("error message: " + res.error_msg);
}
}}}

==3.6 总结==
下面我们举个例子囊括上面所有的技术话题，做个总结。
假设我们想在远程的Linux服务器（ip是9.125.71.115）上执行一个shell脚本。sshxcute_test.sh的内容请见[http://code.google.com/p/sshxcute/wiki/GuidelineOfChineseVersion?ts=1284186106&updated=GuidelineOfChineseVersion#附录1. 附录A]。代码如下：
{{{
// 新建一个SSHExec引用
SSHExec ssh = null;
// 我们下面所有的代码都放在try-catch块中
try {
    // 实例化一个ConnBean对象，参数依次是IP地址、用户名和密码
    ConnBean cb = new ConnBean("9.125.71.115", "username","password");
    // 将刚刚实例化的ConnBean对象作为参数传递给SSHExec的单例方法得到一个SSHExec对象
    ssh = SSHExec.getInstance(cb);		
    // 新建一个ExecCommand对象，引用必须是其继承的CustomTask类
    CustomTask ct1 = new ExecCommand("chmod 755 /home/tsadmin/sshxcute_test.sh");
    // 新建一个ExecShellScript对象，引用必须是其继承的CustomTask类
    CustomTask ct2 = new ExecShellScript("/home/tsadmin","./sshxcute_test.sh","hello world");
    // 连接服务器
    ssh.connect();
    // 上传shell脚本到/home/tsadmin目录
    ssh.uploadSingleDataToServer("data/sshxcute_test.sh", "/home/tsadmin");
    // 执行命令
    ssh.exec(ct1);
    // 执行脚本并且返回一个Result对象
    Result res = ssh.exec(ct2);
    // 检查执行结果，如果执行成功打印输出，如果执行失败，打印错误信息
    if (res.isSuccess)
    {
        System.out.println("Return code: " + res.rc);
        System.out.println("sysout: " + res.sysout);
    }
    else
    {
	System.out.println("Return code: " + res.rc);
	System.out.println("error message: " + res.error_msg);
    }
} 
catch (TaskExecFailException e) 
{
    System.out.println(e.getMessage());
    e.printStackTrace();
} 
catch (Exception e) 
{
    System.out.println(e.getMessage());
    e.printStackTrace();
} 
finally 
{
    ssh.disconnect();	
}
}}}


*输出：*
{{{
SSHExec initializing ...
Session initialized and associated with user credential tsadmin123
SSHExec initialized successfully
SSHExec trying to connect username@9.125.71.115
SSH connection established
Ready to transfer local file 'data/sshxcute_test.sh' to server directory '/home/tsadmin'
Connection channel established succesfully
Start to upload
Upload success
channel disconnect
Command is chmod 755 /home/tsadmin/sshxcute_test.sh
Connection channel established succesfully
Start to run command
Connection channel closed
Check if exec success or not ... 
Execute successfully for command: chmod 755 /home/tsadmin/sshxcute_test.sh
Now wait 5 seconds to begin next task ...
Connection channel disconnect
Command is cd /home/tsadmin ; ./sshxcute_test.sh hello world 
Connection channel established succesfully
Start to run command
Login success

Connection channel closed
Check if exec success or not ... 
Execute successfully for command: cd /home/tsadmin ; ./sshxcute_test.sh hello world 
Now wait 5 seconds to begin next task ...
Connection channel disconnect
R1 Return code: 0
R1 sysout: Login success

SSH connection shutdown
}}}


==3.7 日志==
所有的输出与日志都将保存在你执行SSHXCUTE的路径下，日志的名称为sshxcute.log。如果你把sshxcute.jar导入到你的Eclipse项目中，它将保存在项目的根目录下。


=4. 配置=
SSHXCUTE框架允许你配置很多参数，具体的API调用格式为：

  * `SSHExec.setOption(String optionName, String/int/long value);`

这句声明必须放在任何任务执行前面，配置才生效。

下面的小节具体讲解各个参数的使用方法。

==4.1 判定任务成功与否的过滤关键字==
让我们回顾一下[http://code.google.com/p/sshxcute/wiki/GuidelineOfChineseVersion?ts=1284194028&updated=GuidelineOfChineseVersion#3.5_结果对象 3.5小节]所讲的，每当执行SSHExec.exec(CustomTask)后，都会返回一个包含了结果信息的Result对象。这个对象有个布尔变量——isSuccess，用来判定任务是否执行成功。问题来了，SSHXCUTE是如何判定的呢？它依赖于什么？

默认地，有两个条件判定任务是否执行成功。第一是命令或者脚本的返回码（return code），它必须是0；第二是打印输入的信息，如果不包含以下字符串，则可以判定成功。

  * "Usage", 
  * "usage",
  * "not found",
  * "fail",
  * "Fail",
  * "error",
  * "Error",
  * "exception",
  * "Exception",
  * "not a valid"

返回码是不可配置的，它必须是0，这个是公认的，因为在Linux/UNIX中执行命令或脚本的成功必返回0。

错误信息过滤条件是可以配置的，如果你想这样假定：如果标准输出包含"error",”fail”,”exception”字符串则判定任务执行失败。可以用一下代码：
{{{
String[] reset_keyword = { "error",”fail”,”exception” };
CustomTask ct1 = new ExecCommand("exit 0");
ct1.resetErrSysoutKeyword(reset_keyword);
}}}

这里要注意reset_keyword数组不支持正则表达式。


==4.2 多任务执行时遇到任务失败是继续还是停止==
当有多个任务执行的时候，并不是所有的都会成功。如果遇到失败，你不想继续下面的任务的时候，你可以关闭HALT_ON_FAILURE开关：
{{{
SSHExec.setOption(IOptionName.HALT_ON_FAILURE, false);
}}}

如果遇到失败，你仍然想继续执行剩下的任务，你可以打开HALT_ON_FAILURE开关：
{{{
SSHExec.setOption(IOptionName.HALT_ON_FAILURE, true);
}}}

默认是设为false的。

例如，我们要依次执行“pwd” > “ABCD” >”echo $HOME”，其中第二个命令是错误的，任务执行失败，如果你想忽略这个错误的任务，继续执行剩下的那个”echo $HOME”任务，你可以关闭HALT_ON_FAILURE开关，要么干脆不改变默认值。请看下面的代码：
{{{
SSHExec.setOption(IOptionName.HALT_ON_FAILURE, false);
ConnBean cb = new ConnBean("rfidic-1.svl.ibm.com", "tsadmin","u7i8o9p0");
ssh = SSHExec.getInstance(cb);
CustomTask ct1 = new ExecCommand("pwd");
CustomTask ct2 = new ExecCommand("ABCD");
CustomTask ct3 = new ExecCommand("echo $HOME");
ssh.connect();
Result r1 = ssh.exec(ct1);
Result r2 = ssh.exec(ct2);
Result r3 = ssh.exec(ct3); //仍然执行
System.out.println("Return code: " + r1.rc);
System.out.println("sysout: " + r1.sysout);
System.out.println("error msg: " + r1.error_msg);
System.out.println("Return code: " + r2.rc);
System.out.println("sysout: " + r3.sysout);
System.out.println("error msg: " + r3.error_msg);
}}}

==4.3 SSH端口设置==
默认的SSH连接端口是22，如果你的远程主机用的不是这个端口而是18，你可以这样设置：
{{{
SSHExec.setOption(IOptionName.SSH_PORT_NUMBER, 18);
}}}

==4.4 错误输入临时存放文件路径==
SSHXCUTE会把命令/脚本的错误输出临时存放在一个本地文件中。这仅仅是内部需要，用户不必改变这个文件的路径。默认的的存储路径是$USERHOME/sshxcute_err.msg。

例如：
  * C:\Documents and Settings\Administrator\sshxcute_err.msg 对于Windows
  * /home/user/sshxcute_err.msg对于Linux/UNIX

*强烈建议用户不要修改这个参数*。如果想改变错误临时文件路径请这样做：
{{{
SSHExec.setOption(IOptionName.ERROR_MSG_BUFFER_TEMP_FILE_PATH, "c:\\123.err");
}}}

==4.5 不同任务之间的间隔时间==
当多任务依次执行时，你可以设置它们之间的间隔时间。这意味着当前一个任务执行结束后，要Sleep也就是等待一段时间再继续执行下一个任务。这在一种情形下极其有用，比如前一个任务执行需要很长时间，后一个任务要完全等它结束后才能开始。参考下面代码：
{{{
SSHExec.setOption(IOptionName.INTEVAL_TIME_BETWEEN_TASKS, 5000l);
}}}

注意这个参数的类型必须是长整形，所以别忘记加“l”。

==4.6 超时==
每个任务都要在一定时间内完成，如果超过这个时间，程序会自动退出。这个时间就叫做TIMOUT。你可以这样设置timeout参数：
{{{
SSHExec.setOption(IOptionName.TIMEOUT, 36000l);
}}}

注意这个参数的类型必须是长整形，所以别忘记加“l”。


==4.7 打印所有参数==
要打印出所有参数，参考下面代码：
{{{
SSHExec.showEnvConfig();
}}}

输出：
{{{
******************************************************
The list below shows sshxcute configuration parameter
******************************************************
TIMEOUT => 36000
HALT_ON_FAILURE => true
INTEVAL_TIME_BETWEEN_TASKS => 5000
SSH_PORT_NUMBER => 22
ERROR_MSG_BUFFER_TEMP_FILE_PATH => c:\123.err
}}}


=5. API扩展=
这个章节是为想基于SSHXCUTE做扩展的开发人员读的。开发者可以开发适用于自己项目的各种任务。
所有的任务都必须继承CustomTask类。这个类包含以下抽象方法：

{{{
       /**
	 * 通过命令或脚本的输出检查任务是否执行成功
	 * 
	 * @param stdout
	 * @return 如果成功返回true，失败返回false
	 */
	protected abstract Boolean checkStdOut(String stdout);
	
	/**
	 * 通过返回代码检查任务是否执行成功
	 * 
	 * @param exitCode 
	 * @return 如果成功返回true，失败返回false
	 */
	protected abstract Boolean checkExitCode(int exitCode);

	/**
	 * 返回要在远程机器上执行的命令
	 * 
	 * @return 命令行字符串
	 */
	public abstract String getCommand();
	
	/**
	 * 任务的描述信息
	 * 
	 * @return 任务描述信息字符串
	 */
	public abstract String getInfo();
}}}


如果你想新建一种任务类型，之间覆盖CustomTask中的这些方法即可。下面是一个实际的场景来展示如何扩展并适用自定义类型的任务。

*需求：*
产品A有一个deployMetadata.sh 的shell脚本。开发组不想使用ExecShellScript类，而想使用自定义类型的任务。DeployMetadata.sh的使用方法是
{{{
/opt/ProductA/bin/deployMetadata.sh –dba_user=system –dba_password=pw4dba
}}}

*实现：*
{{{
public class DeployMetadata extends CustomTask{

	protected String dba_user = "";
	
	protected String dba_password = "";
	
	public DeployMetadata(String dba_user, String dba_password){
		this.dba_user = dba_user;
		this.dba_password = dba_password;
	}
	
	
	public Boolean checkStdOut(String stdout){
		Iterator<String> iter = err_sysout_keyword_list.iterator();
		while(iter.hasNext()){
			if (stdout.contains(iter.next()))
			{
				return false;
			}
		}
		return true;
	}
	
	public Boolean checkExitCode(int exitCode){
		if (exitCode == 0)
			return true;
		else
			return false;
	}
	
	public String getCommand(){
		return "/opt/ProductA/bin/deployMetadata.sh" + " -dba_user=" + dba_user + " -dba_password=" + dba_password;
	}
	
	
	public String getInfo(){
		return "Deploy metadata ";
	}
}
}}}

*使用方法：*
{{{
CustomTask task1 = new DeployMetadata ("system", “pw4dba”);
ssh.connect();
ssh.exec(task1);
}}}

=6. 代码举例=
==例1==
{{{
                SSHExec ssh = null;
		try {
			ConnBean cb = new ConnBean("grnvm164.svl.ibm.com", "vmadmin","vmadmin123");
			ssh = SSHExec.getInstance(cb);		
			CustomTask echo = new ExecCommand("pwd");
			ssh.connect();
			Result res = ssh.exec(echo);
			if (res.isSuccess)
			{
				System.out.println("Return code: " + res.rc);
				System.out.println("sysout: " + res.sysout);
			}
			else
			{
				System.out.println("Return code: " + res.rc);
				System.out.println("error message: " + res.error_msg);
			}
		} catch (TaskExecFailException e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} catch (Exception e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} finally {
			ssh.disconnect();	
		}
}}}

==例2==
{{{
                SSHExec ssh = null;
		try {
			SSHExec.setOption(IOptionName.HALT_ON_FAILURE, true);
			SSHExec.setOption(IOptionName.SSH_PORT_NUMBER, 22);
			SSHExec.setOption(IOptionName.ERROR_MSG_BUFFER_TEMP_FILE_PATH, "c:\\123.err");
			SSHExec.setOption(IOptionName.INTEVAL_TIME_BETWEEN_TASKS, 100000l);
			SSHExec.setOption(IOptionName.TIMEOUT, 36000l);
			SSHExec.showEnvConfig();
			
			ConnBean cb = new ConnBean("rfidic-1.svl.ibm.com", "tsadmin","u7i8o9p0");
			ssh = SSHExec.getInstance(cb);		
			CustomTask task1 = new ExecCommand("echo 123");
			CustomTask task2 = new ExecCommand("abcd");
			CustomTask task3 = new ExecCommand("pwd");
			ssh.connect();
			ssh.exec(task1);
			ssh.exec(task2);
			System.out.println("This should not print!");
			ssh.exec(task3);
			System.out.println("Task3 does not execute");
		} catch (TaskExecFailException e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} catch (Exception e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} finally {
			ssh.disconnect();	
		}
}}}

==例3==
{{{
                SSHExec ssh = null;
		try {
			ConnBean cb = new ConnBean("grnvm164.svl.ibm.com", "tsadmin","tsadmin123");
			ssh = SSHExec.getInstance(cb);		
			CustomTask ct1 = new ExecCommand("chmod 755 /home/tsadmin/sshxcute_test.sh");
			CustomTask ct2 = new ExecShellScript("/home/tsadmin","./sshxcute_test.sh","hello world");
			ssh.connect();
			ssh.uploadSingleDataToServer("data/sshxcute_test.sh", "/home/tsadmin");
			ssh.exec(ct1);
			Result res = ssh.exec(ct2);
			if (res.isSuccess)
			{
				System.out.println("R1 Return code: " + res.rc);
				System.out.println("R1 sysout: " + res.sysout);
			}
		} catch (TaskExecFailException e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} catch (Exception e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} finally {
			ssh.disconnect();	
		}
}}}

==例4==
{{{
                String uploadFileDirPath = "/home/tsadmin/data";
		String RFIDIC_HOME = "/opt/ibm/InfoSphere/TraceabilityServer";
		
		SSHExec ssh = null;
		try {
			SSHExec.setOption(IOptionName.HALT_ON_FAILURE, false);
			ConnBean cb = new ConnBean("rfidic-1.svl.ibm.com", "tsadmin","u7i8o9p0");
			ssh = SSHExec.getInstance(cb);
			CustomTask chmod = new ExecCommand("chmod -R 755 /home/tsadmin/data");
			CustomTask removePedigreeDefFromRFIDICServerXml = new ExecShellScript(uploadFileDirPath + "/shellscript","./RemovePedigreeMetaFromRFIDICServer.sh",RFIDIC_HOME);
			CustomTask copyMetadata = new ExecCommand("cp -rf " + uploadFileDirPath + "/metadata/*.xml " + RFIDIC_HOME + "/etc");
			CustomTask copyLib = new ExecCommand("cp -f " + uploadFileDirPath + "/jar/*.jar " + RFIDIC_HOME + "/lib");
			CustomTask registerLibToWAS = new ExecCommand("/usr/IBM/WebSphere/AppServer/bin/wsadmin.sh -f " + uploadFileDirPath + "/jacl/WASLibraryAddClassPath.jacl -user wsadmin -password was4me");
			CustomTask deployMetadata = new ExecShellScript(RFIDIC_HOME + "/bin/deployMetadata.sh -dba_user=db2inst1 -dba_password=passw0rd -force_drop_tables -force_stop_was");
			CustomTask ImportMasterdata = new ExecShellScript(RFIDIC_HOME + "/bin/import-masterdata.sh " + uploadFileDirPath + "/masterdata/*.xml");
			CustomTask startRFIDIC = new ExecCommand(RFIDIC_HOME + "/bin/startRFIDIC.sh -components=was,capture");
			CustomTask importEvents = new ExecShellScript(RFIDIC_HOME + "/bin/submitEvent.sh -queue myeventq " + uploadFileDirPath + "/event/group1_events.xml");
			ssh.connect();
			ssh.uploadAllDataToServer("c:/data2/data", "/home/tsadmin");
			Result r_chmod = ssh.exec(chmod);
			System.out.println("Return code: " + r_chmod.rc);
			System.out.println("sysout: " + r_chmod.sysout);
			System.out.println("error msg: " + r_chmod.error_msg);
			
			Result r_removePedigreeDefFromRFIDICServerXml = ssh.exec(removePedigreeDefFromRFIDICServerXml);
			System.out.println("Return code: " + r_removePedigreeDefFromRFIDICServerXml.rc);
			System.out.println("sysout: " + r_removePedigreeDefFromRFIDICServerXml.sysout);
			System.out.println("error msg: " + r_removePedigreeDefFromRFIDICServerXml.error_msg);
			
			Result r_cp = ssh.exec(copyMetadata);	
			System.out.println("Return code: " + r_cp.rc);
			System.out.println("sysout: " + r_cp.sysout);
			System.out.println("error msg: " + r_cp.error_msg);
			
			ssh.exec(copyLib);
			Result r_registerLibToWAS = ssh.exec(registerLibToWAS);
			System.out.println("Return code: " + r_registerLibToWAS.rc);
			System.out.println("sysout: " + r_registerLibToWAS.sysout);
			System.out.println("error msg: " + r_registerLibToWAS.error_msg);
			
			Result r_deployMetadata = ssh.exec(deployMetadata);
			System.out.println("Return code: " + r_deployMetadata.rc);
			System.out.println("sysout: " + r_deployMetadata.sysout);
			System.out.println("error msg: " + r_deployMetadata.error_msg);
			
			Result r_ImportMasterdata = ssh.exec(ImportMasterdata);
			System.out.println("Return code: " + r_ImportMasterdata.rc);
			System.out.println("sysout: " + r_ImportMasterdata.sysout);
			System.out.println("error msg: " + r_ImportMasterdata.error_msg);
			
			Result r_startRFIDIC = ssh.exec(startRFIDIC);
			System.out.println("Return code: " + r_startRFIDIC.rc);
			System.out.println("sysout: " + r_startRFIDIC.sysout);
			System.out.println("error msg: " + r_startRFIDIC.error_msg);
			
			Result r_importEvents = ssh.exec(importEvents);
			System.out.println("Return code: " + r_importEvents.rc);
			System.out.println("sysout: " + r_importEvents.sysout);
			System.out.println("error msg: " + r_importEvents.error_msg);
		} catch (TaskExecFailException e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} catch (Exception e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		} finally {
			ssh.disconnect();	
		}
}}}

=附录1.=
{{{
#!/bin/bash
if [ $# -ne 2 ];then
        echo "usage: sshxcute_test.sh username password"
        exit 1
fi
export USERNAME=$1
export PASSWORD=$2

if [ "$USERNAME" = "hello" -a "$PASSWORD" = "world" ];then
	echo "Login success"
	exit 0
fi
echo "Login falied"
exit 2
}}}